# Understanding ECMAScript 6

### Блочные привязки

#### Объявление переменных

##### var

Обьявления переменных с помощью var интерпретируется так, как если бы оно находилось в начале функции (или глобальной области видимости), 
независимо от того, где оно находится. 
    
    function getValue(condition) {
        if (condition) {
            var value = "blue";
            
            return value;
        } else {
            // переменная var существует здесь и имеет значение undefined
            return null;
        }
        // переменная var существует здесь и имеет значение undefined
    }

Интерпретатор меняет функцию следующим образом:
    
        function getValue(condition) {
            var value;
            
            if (condition) {
                var value = "blue";
                
                return value;
            } else {
                return null;
            }
        }

Таким образом поднятие (hoisting) переменной с помощью var всегда происходит в начале функции, а инициализация остается на месте.

##### let

Объявления let не поднимаются к началу блока, поэтому их лучше размещать в блоке первыми, чтобы сделать доступными во всем блоке.

    function getValue(condition) {
        if (condition) {
            let value = "blue";
    // прочий код
            return value;
        } else {
            // переменная value не существует здесь
            return null;
        }
        // переменная value не существует здесь
    }

Повторное использование идентификатора в объявлении let в текущей области видимости вызовет ошибку:

    var count = 42;
    let count = 24; // вызовет ошибку
    
Однако в следующем примере ошибки не будет, потому что внутри блока if эта новая переменная закроет доступ к глобальной переменной count до конца блока:
    
    var count = 30;
    if (condition) {
        // не вызовет ошибку
        let count = 40;
        // прочий код
    }     
    
##### const
Значение const невозможно изменить после инициализации. Поэтому каждая привязка const должна включать значение для инициализации:

    // недопустимо
    const count;
    
    // допустимо
    // const count = 12;

Область видимости констант такая же как у переменных, объявленных с помощью let. Повторное объявление const вызовет ошибку.
У констант есть одна особенность, которая легко может запутать - объявление const не позволяет изменить привязку, но не 
значение. Следовательно, объявление объекта с помощью const не помешает изменить его. Например:

    const person = {
        name: "Nicholas"
    };
     // работает
    person.name = "Greg";
    // вызовет ошибку
    person = {
        name: "Greg"
    };


##### Несколько примеров с var, let и const:
 
    let a = 23;
    let a = 56; // вызовет ошибку
    a = 89; // переопределит переменную
    console.log(a) // 89


    const maxItems = 5;
    const maxItems = 15; // вызовет ошибку
    maxItems = 6; // вызовет ошибку
    
    
    function sayHello() {
      console.log(name);
      console.log(age);
      var name = "Bob";
      let age = 20;
    }
    
    sayHi(); // undefined and ReferenceError


#### Блочные привязки в циклах

На первый взгляд кажется, что следующий код должен вывести числа от 0 до 9, но в действительности он десять раз выведет число 10:

    var funcs = [];
    for (var i = 0; i < 10; i++) {
        funcs.push(function() {
            console.log(i);
        });
    }
    funcs.forEach(function(func) {
        func();     // десять раз выведет число "10"
    });
    
Это происходит потому что во всех итерациях цикла используется одна и та же переменная i, то есть все функции, созданные 
в теле цикла, будут хранить ссылку на одну и ту же переменную. После последней итерации цикла переменная i получит значение 
10, которое выведут все инструкции console.log(i).
Привязки let и const помогут этого избежать:

    var funcs = [];
    for (let i = 0; i < 10; i++) {
        funcs.push(function() {
            console.log(i);
        });
    }
    funcs.forEach(function(func) {
        func();     // выведет 0, 1, 2, ..., 9
    })
    
В каждой итерации цикл создает новую переменную и инициализирует ее значением одноименной переменной из предыдущей итерации.

В цикле for можно использовать также переменную const для объявления переменной в выражении инициализации цикла, 
только если потом она не будет изменяться: 

    var funcs = [];
    // вызовет ошибку после первой итерации
    for (const i = 0; i < 10; i++) {
        funcs.push(function() {
            console.log(i);
        });
    }

Первая итерация выполнится, но при следующей итерации попытка изменить константу вызывает ошибку:

#### Блочные привязки на глобальном уровне

Еще одно отличие let и const от var заключается в поведении на глобальном уровне.
Когда объявление var используется в глобальной области видимости, оно создает новую глобальную переменную как свойство 
глобального объекта (window — в браузерах):

    var RegExp = "Hello!";
    console.log(window.RegExp); // "Hello!"
    
    var ncz = "Hi!";
    console.log(window.ncz); // "Hi!"

Объявления let или const создают новые привязки в глобальной области видимости, но не добавляют свойства в глобальный объект.
Отсутствие влияния let и const на глобальный объект делает их использование в глобальной области видимости более безопасным.
